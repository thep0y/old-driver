# PDF 老司机

老司机开的是最难的车。

## 简介

本项目可视化部分使用 tauri + React 开发，PDF 处理部分使用国人开发的 low-level 库 lopdf，因为是 low-level，对 PDF 的处理都是低层级的、未经封装的代码，而我对 PDF 了解不深，所以非常欢迎对 PDF 有了解的人提交 PR 来改进代码中的不足之处。

## 开发环境

需要以下环境：

- nodejs 18+ with pnpm
- rust

需要以下依赖：

- [upx](https://github.com/upx/upx)：添加到环境变量

## 原理

### 尺寸转换

pdf 单元尺寸是 $1/72\ inch$ 或 $0.35\ mm$，需要根据此单元计算坐标或尺寸。

如 letter 的尺寸为 $8.5\ inch \times 11\ inch$，换算成 pdf 单元为 (612.0, 792.0)。

本程序默认采用 A4 尺寸($210\ mm \times 297\ mm$)，换算成 pdf 单元为 (595.2756, 841.8898)，有的 pdf 编辑软件会将此尺寸四舍五入设置为 (595, 842)，损失的像素精度已不是肉眼可见，但四舍五入也没什么意义。

## 决择

### 1 缩略图的生成

当前使用的方案是生成全部缩略图后通过数组返回给前端，但这会造成一定时间的等待。

另一种方案是通过事件监听，后端处理完一张缩略图便通过`emit`通知前端：

```rust
use tauri::event::{Event, emit};

fn sample() -> Result<(), String> {
    for i in items {
        emit("sample", i).map_err(|e| e.to_string())?;
    }
    
    Ok(())
}
```

前端就渲染一张缩略图：

```tsx
import { appWindow } from '@tauri-apps/api/window'

const ImageList: React.FC = () => {
  // ...
  useEffect(() => {
    void appWindow.listen<string[]>('sample', async (item) => {
      // 处理 item
    })
  })
}
```

这样前端页面的等待时间就大大缩短，甚至用户都看到不等待动画，这种方案的问题在于当缩略图未全部生成时用户的任何操作都应是无效操作，所以暂时未采用此方案。

## 目标

未来实现当前未实现的功能或特性如下：

- [ ] 添加全局设置按钮，允许使用一些全局设置
  - [ ] 本地缓存
    - [ ] 缓存缩略图：开启此项时会将缩略图保存到本地，会占用一部分磁盘空间，但对重复图片不会重新生成缩略图，当你经常使用相同的图片生成 PDF 时开启此项能提高导出效率。
    - [ ] 缓存图片对象：开启此项时会将转换后的图片对象保存到本地，会占用一部分磁盘空间，但对重复图片不会重新生成 PDF 图片对象，当你经常使用相同的图片生成 PDF 时开启此项能提向导出效率。
  - [ ] 启用自动更新：开启此项后在以后的每次启动程序时会检查更新，如果有新版本会自动更新。
    - [ ] 更新镜像：因为 github 在国内访问有问题，可以采用自定义镜像的方式（如 ghproxy.com）加速。
  - [ ] 自动切换黑色模式
  - [ ] 全局图像设置
    - [ ] 图像压缩：对一些体积太大，但导出到 PDF 后又不需要太高清晰度的图片进行压缩可大幅减小 PDF 体积。
      - [ ] 最大图片体积：将所有超过最大图片体积的图片压缩到最大图片体积或近似大小。
      - [ ] 固定压缩比例：开启此项后对所有超过最大图片体积的图片进行同比例压缩。
- [ ] 图像旋转（左右 90 度）
- [ ] 图像翻转（水平、垂直）
- [ ] 单个图像设置
  - [ ] 图像压缩（二选一）：对一些体积太大，但导出到 PDF 后又不需要太高清晰度的图片进行压缩可大幅减小 PDF 体积。
    - [ ] 目标体积：将此图片的体积压缩到目标体积或近似大小。
    - [ ] 压缩比例：将此图片按指定比例压缩。

